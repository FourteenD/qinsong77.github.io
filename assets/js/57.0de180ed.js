(window.webpackJsonp=window.webpackJsonp||[]).push([[57],{600:function(t,e,r){"use strict";r.r(e);var _=r(25),v=Object(_.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("ul",[r("li",[r("a",{attrs:{href:"https://www.jianshu.com/p/81128ab478e9",target:"_blank",rel:"noopener noreferrer"}},[t._v("面试官: 写过『通用前端组件』吗?"),r("OutboundLink")],1)]),t._v(" "),r("li",[r("a",{attrs:{href:"https://juejin.cn/post/6913788953971654663",target:"_blank",rel:"noopener noreferrer"}},[t._v("使用mono-repo实现跨项目组件共享"),r("OutboundLink")],1)])]),t._v(" "),r("h3",{attrs:{id:"前端组件库的设计原则"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#前端组件库的设计原则"}},[t._v("#")]),t._v(" 前端组件库的设计原则")]),t._v(" "),r("h4",{attrs:{id:"细粒度的考量"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#细粒度的考量"}},[t._v("#")]),t._v(" 细粒度的考量")]),t._v(" "),r("p",[t._v("从软件的设计模式上，确定组件的"),r("strong",[t._v("单一职责原则")]),t._v("，原则上一个组件只专注一件事情，单一职责的组件的好处很明显，由于职责单一就可以最大可能性地"),r("strong",[t._v("复用")]),t._v("组件。保证组件单一的最大好处"),r("strong",[t._v("就是方便单元测试")]),t._v("。\n同时要考虑划分过细而导致"),r("strong",[t._v("组件碎片化")]),t._v("的问题。")]),t._v(" "),r("h4",{attrs:{id:"通用性考量"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#通用性考量"}},[t._v("#")]),t._v(" 通用性考量")]),t._v(" "),r("p",[t._v("组件的形态(DOM结构)永远是千变万化的,但是其行为(逻辑)是固定的,因此通用组件的秘诀之一就是将 DOM 结构的控制权交给开发者,组件只负责行为和最基本的 DOM 结构。")]),t._v(" "),r("p",[t._v("预留合适的api，或者叫pros等，比如提供自定义渲染render，提过组件核心能力的同事也能根据业务上进行扩展。")]),t._v(" "),r("h4",{attrs:{id:"原子性设计"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#原子性设计"}},[t._v("#")]),t._v(" 原子性设计")]),t._v(" "),r("p",[t._v("比如样式主题，在"),r("code",[t._v("sketch")]),t._v("文件中将最小颗粒度“原子(如颜色)”按照其使用意图作为名称进行命名；颗粒度再复杂一级的“分子(如字体)”变量名则由"),r("code",[t._v("typeface/weight/color/size")]),t._v("的组合排列产生。")]),t._v(" "),r("h4",{attrs:{id:"控制反转设计ioc"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#控制反转设计ioc"}},[t._v("#")]),t._v(" 控制反转设计IOC")]),t._v(" "),r("p",[t._v("不是从上层开始使用底层构建或者组装依赖。而是从底层开始设计叠加，感觉有点像是从递归到动态规划的过程。比较明显的一个就是React中的高阶组件（HOC）")]),t._v(" "),r("hr"),t._v(" "),r("p",[t._v("基于"),r("code",[t._v("Sketch")]),t._v("中的symbol功能，前端也需要将组件进行原子化，并根据"),r("code",[t._v("symbol")]),t._v("的变量命名将常用的大小、颜色创建为变量。")]),t._v(" "),r("p",[t._v("前端组件根据功能以及颗粒度可以分为“基础组件”和“高阶组件”。基础组件一般是页面中颗粒度中最小也是最常用的组件，例如"),r("code",[t._v("input")]),t._v("，"),r("code",[t._v("button")]),t._v('等；高阶组件通常是由基础组件进行一定的变形、组合或两者兼有而形成的；而高阶组件+基础组件最终组成了完整的页面。 为了满足2B场景下的整体风格替换，所有组件在开发的时候要将用到的颜色、字体等"原子"用变量的方式引入。')]),t._v(" "),r("p",[t._v("在目前前端开发中，样式的变量创建方式主要有两种：一是基于css原生支持的自定义变量，二是基于"),r("code",[t._v("less")]),t._v("、"),r("code",[t._v("scss")]),t._v("等css预编译器。要到自定义变量可能存在的浏览器兼容性问题，组件库可以采用了less作为样式开发的语言。less 是一门 CSS 预处理语言，除了之前提到的变量功能，还有嵌套、混合（mixin）、函数等方便的功能。")]),t._v(" "),r("h3",{attrs:{id:"前端组件设计原则"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#前端组件设计原则"}},[t._v("#")]),t._v(" 前端组件设计原则")]),t._v(" "),r("ul",[r("li",[t._v("层次结构和 UML 类图")]),t._v(" "),r("li",[t._v("扁平化、面向数据的 state/props")]),t._v(" "),r("li",[t._v("更加纯粹的 "),r("code",[t._v("State")]),t._v(" 变化")]),t._v(" "),r("li",[t._v("高内聚，低耦合")]),t._v(" "),r("li",[t._v("辅助代码分离")]),t._v(" "),r("li",[t._v("提炼精华")]),t._v(" "),r("li",[t._v("及时模块化")]),t._v(" "),r("li",[t._v("集中/统一的状态管理")])]),t._v(" "),r("h3",{attrs:{id:"element-ui"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#element-ui"}},[t._v("#")]),t._v(" Element-ui")]),t._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://juejin.cn/post/6844904003541663757",target:"_blank",rel:"noopener noreferrer"}},[t._v("Element-UI（2.11.1） 构建流程"),r("OutboundLink")],1)]),t._v(" "),r("li",[r("a",{attrs:{href:"https://mp.weixin.qq.com/s/nIPYXeqdoKZbFe9baZJVyw",target:"_blank",rel:"noopener noreferrer"}},[t._v("组件库的整体设计"),r("OutboundLink")],1)])])])}),[],!1,null,null,null);e.default=v.exports}}]);