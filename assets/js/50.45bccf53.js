(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{568:function(v,_,t){"use strict";t.r(_);var s=t(25),o=Object(s.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h3",{attrs:{id:"阻塞、非阻塞和同步、异步"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#阻塞、非阻塞和同步、异步"}},[v._v("#")]),v._v(" 阻塞、非阻塞和同步、异步")]),v._v(" "),t("p",[v._v("阻塞和非阻塞 I/O 其实是针对操作系统内核而言的，而不是 nodejs 本身。阻塞 I/O 的特点就是"),t("strong",[v._v("一定要等到操作系统完成所有操作后才表示调用结束")]),v._v("，而非阻塞 I/O 是调用后立马返回，不用等操作系统内核完成操作。")]),v._v(" "),t("p",[v._v("阻塞I/O造成CPU等待I/O，CPU的处理能力不能充分利用，浪费等待时间。\n非阻塞I/O不带数据直接返回，性能提高很大，但完整的I/O并没有完成，所有应用程序需要重复调用I/O操作来确认是否完成，这种叫"),t("strong",[v._v("轮询")])]),v._v(" "),t("p",[v._v("nodejs中的异步 I/O 采用"),t("strong",[v._v("多线程")]),v._v("的方式，由 "),t("code",[v._v("EventLoop")]),v._v("、"),t("code",[v._v("I/O 观察者")]),v._v("，"),t("code",[v._v("请求对象")]),v._v("、"),t("code",[v._v("线程池")]),v._v("四大要素相互配合，共同实现。")]),v._v(" "),t("h3",{attrs:{id:"js"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#js"}},[v._v("#")]),v._v(" Js")]),v._v(" "),t("p",[v._v("JS属于解释型语言，对于解释型的语言说，解释器会对源代码做如下分析:")]),v._v(" "),t("ol",[t("li",[v._v("通过词法分析和语法分析生成 AST(抽象语法树)，接下来会生成执行上下文")]),v._v(" "),t("li",[v._v("将 AST 转换为字节码（字节码是介于"),t("code",[v._v("AST")]),v._v(" 和 "),t("code",[v._v("机器码")]),v._v("之间的一种代码，但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码然后执行。）")]),v._v(" "),t("li",[v._v("由解释器逐行执行字节码，遇到热点代码启动编译器进行编译，生成对应的机器码, 以优化执行效率。")])]),v._v(" "),t("p",[v._v("如果把AST直接转成机器码给V8执行，也可以，但转成的机器码的体积太大，引发了严重的内存占用问题。")]),v._v(" "),t("p",[v._v("所以"),t("code",[v._v("解释器")]),v._v("是将字节码转成机器码。")]),v._v(" "),t("p",[v._v("在执行字节码的过程中，如果发现某一部分代码重复出现，那么 V8 将它记做"),t("code",[v._v("热点代码")]),v._v("(HotSpot)，然后将这段代码"),t("code",[v._v("编译")]),v._v("成"),t("code",[v._v("机器码")]),v._v("保存起来，这个用来编译的工具就是V8的"),t("code",[v._v("编译器")]),v._v("(也叫做TurboFan) , 因此在这样的机制下，代码执行的时间越久，那么执行效率会越来越高，因为有越来越多的字节码被标记为热点代码，遇到它们时直接执行相应的机器码，不用再次将转换为机器码。")]),v._v(" "),t("p",[v._v("编译器和解释器的 根本区别在于前者会编译生成二进制文件但后者不会。")]),v._v(" "),t("p",[v._v("并且，这种字节码跟编译器和解释器结合的技术，称之为即时编译(JIT)。")]),v._v(" "),t("h4",{attrs:{id:"什么是-hash以及hash碰撞"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是-hash以及hash碰撞"}},[v._v("#")]),v._v(" "),t("a",{attrs:{href:"https://www.zhihu.com/question/26762707/answer/890181997",target:"_blank",rel:"noopener noreferrer"}},[v._v("什么是 hash以及hash碰撞？"),t("OutboundLink")],1)]),v._v(" "),t("p",[v._v("哈希算法的实质是对原始数据的有损压缩，有损压缩后的固定字长用作唯一标识原始数据。基本原理就是把任意长度的输入，通过Hash算法变成固定长度的输出。这个映射的规则就是对应的Hash算法，而原始数据映射后的二进制串就是哈希值。活动开发中经常使用的"),t("strong",[v._v("MD5")]),v._v("和"),t("strong",[v._v("SHA")]),v._v("都是历史悠久的Hash算法。")]),v._v(" "),t("p",[v._v("若不同的原始数据被有损压缩后产生了相同的结果，该现象称为哈希碰撞。解决的常用的算法是"),t("strong",[v._v("链地址法")]),v._v("和"),t("strong",[v._v("开放地址法")]),v._v("。")]),v._v(" "),t("p",[t("strong",[v._v("哈希表")]),v._v("属于一种物理存储结构，它应用了"),t("strong",[v._v("哈希算法")]),v._v("因此称之为哈希表。物理存储结构共4种：顺序、链式、索引、散列，其中顺序和链式最常见，这两种存储结构的共同特征是"),t("strong",[v._v("元素之间有着映射关系")]),v._v("，而哈希表（散列存储结构）的"),t("strong",[v._v("元素之间相互独立")]),v._v("。索引存储结构类似现实世界中的字典目录，在此不多赘述。哈希表的实现方式：给定一个任意类型的数据，称为"),t("strong",[v._v("键")]),v._v("，使用"),t("strong",[v._v("哈希算法")]),v._v('加工该数据，把生成的结果作为键的存储地址。例如给定一个字符串参数 "str"，该键对应的元素是"jack"，那么"jack"的存储地址就是通过哈希算法对"str"进行加工生成的。这么一来，每当存取元素时不会像传统的数据结构逐个遍历、一一对比，而是通过哈希算法直接获取元素的存储地址，因此哈希表会比传统的数据结构更为高效，这也是使用哈希表的原因。')])])}),[],!1,null,null,null);_.default=o.exports}}]);