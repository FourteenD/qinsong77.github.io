---
title: 学习笔记
---

## 内置类型
JavaScript目前有八种内置类型（包含ES6的symbol）：
- null
- undefined
- string
- number
- boolean
- object
- symbol
- BigInt

#### typeof null 为 'object'的bug
> JavaScript中的数据在底层是以二进制存储，比如null所有存储值都是0，但是底层的判断机制，只要前三位为0，就会判定为object，所以才会有typeof null === 'object'这个bug。

## 语言中所有的底层存储方式是是什么。

- 数组(Array)
数组是一种聚合数据类型，它是将具有相同类型的若干变量有序地组织在一起的集合。数组可以说是最基本的数据结构，在各种编程语言中都有对应。一个数组可以分解为多个数组元素，按照数据元素的类型，数组可以分为整型数组、字符型数组、浮点型数组、指针数组和结构数组等。数组还可以有一维、二维以及多维等表现形式。

- 栈( Stack)
栈是一种特殊的线性表，它只能在一个表的一个固定端进行数据结点的插入和删除操作。栈按照后进先出的原则来存储数据，也就是说，先插入的数据将被压入栈底，最后插入的数据在栈顶，读出数据时，从栈顶开始逐个读出。栈在汇编语言程序中，经常用于重要数据的现场保护。栈中没有数据时，称为空栈。

- 队列(Queue)
队列和栈类似，也是一种特殊的线性表。和栈不同的是，队列只允许在表的一端进行插入操作，而在另一端进行删除操作。一般来说，进行插入操作的一端称为队尾，进行删除操作的一端称为队头。队列中没有元素时，称为空队列

- 链表( Linked List)
链表是一种数据元素按照链式存储结构进行存储的数据结构，这种存储结构具有在物理上存在非连续的特点。链表由一系列数据结点构成，每个数据结点包括数据域和指针域两部分。其中，指针域保存了数据结构中下一个元素存放的地址。链表结构中数据元素的逻辑顺序是通过链表中的指针链接次序来实现的。

- 树( Tree)
树是典型的非线性结构，它是包括，2个结点的有穷集合K。在树结构中，有且仅有一个根结点，该结点没有前驱结点。在树结构中的其他结点都有且仅有一个前驱结点，而且可以有两个后继结点，m≥0

- 图(Graph)
图是另一种非线性数据结构。在图结构中，数据结点一般称为顶点，而边是顶点的有序偶对。如果两个顶点之间存在一条边，那么就表示这两个顶点具有相邻关系

- 堆(Heap)
堆是一种特殊的树形数据结构，一般讨论的堆都是二叉堆。堆的特点是根结点的值是所有结点中最小的或者最大的，并且根结点的两个子树也是一个堆结构

- 散列表(Hash)
散列表源自于散列函数(Hash function)，其思想是如果在结构中存在关键字和T相等的记录，那么必定在F(T)的存储位置可以找到该记录，这样就可以不用进行比较操作而直接取得所查记录

## JavaScript使用的是 堆(Heap) 和 栈( Stack)
JavaScript基本类型数据都是直接按值存储在栈中的(Undefined、Null、不是new出来的布尔、数字和字符串)，每种类型的数据占用的内存空间的大小是确定的，并由系统自动分配和自动释放。这样带来的好处就是，内存可以及时得到回收，相对于堆来说 ，更加容易管理内存空间。

JavaScript引用类型数据被存储于堆中 (如对象、数组、函数等，它们是通过拷贝和new出来的）。其实，说存储于堆中，也不太准确，因为，引用类型的数据的地址指针是存储于栈中的，当我们想要访问引用类型的值的时候，需要先从栈中获得对象的地址指针，然后，在通过地址指针找到堆中的所需要的数据。


## this的指向（https://juejin.im/post/6844903496253177863）
> 在 ES5 中，其实 this 的指向，始终坚持一个原理：this 永远指向最后调用它的那个对象。
#### 改变 this 的指向的方法
- 使用 ES6 的箭头函数
- 在函数内部使用 _this = this
- 使用 apply、call、bind
- new 实例化一个对象


## instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上
语法
> object instanceof constructor
>

#### set, map, weakMap, weakSet(https://juejin.im/post/6844904169417998349)

#### 使用Object.prototype.hasOwnProperty.call(obj, key) 比用obj.hasOwnProperty安全

#### 没有副作用的方法和函数被称为纯函数。

#### web储存方案 https://juejin.im/post/6844904192549584903

## 事件循环
- https://xieyufei.com/2019/12/30/Quiz-Eventloop.html
- https://juejin.im/post/6844903971228745735
- https://juejin.im/post/6844903711106400264
- https://juejin.im/post/6844903752621637645
[浏览器与Node的事件循环(Event Loop)有何区别](https://juejin.im/post/6844903761949753352)
>JavaScript 是单线程、异步、非阻塞、解释型脚本语言。JS引擎会将JS脚本进行编译和执行
>JavaScript 的设计就是为了处理浏览器网页的交互（DOM操作的处理、UI动画等），决定了它是一门单线程语言。如果有多个线程，它们同时在操作 DOM，那网页将会一团糟。
>执行栈（先进后出，执行栈中存放正在执行的代码）和堆（堆中存放变量的值）
>JS执行栈和渲染线程是相互阻塞的
> 事件循环实现异步
>事件循环就是用来做调度的，浏览器和NodeJS中的事件循坏就好像操作系统的调度器一样。
### 事件循环的流程大致如下
-    1、所有任务都在主线程上执行，形成一个执行栈。
-   2、主线程发现有异步任务，就在“任务队列”之中加入一个任务事件。
-   3、一旦“执行栈”中的所有同步任务执行完毕，系统就会读取“任务队列”（先进先出原则）。那些对应的异步任务，结束等待状态，进入执行栈并开始执行。
-   4、主线程不断重复上面的第三步，这样的一个循环称为事件循环。

----
- 执行一个宏任务（栈中没有就从事件队列中获取）


- 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中


- 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）


- 当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染


- 渲染完毕后，JS引擎线程继续，开始下一个宏任务（从宏任务队列中获取）
### 宏任务包括：
- script(整体代码)
- setTimeout, setInterval, setImmediate,
- I/O
- UI rendering
    　　
### 微任务包括：
    
- process.nextTick
- Promise
- MutationObserver(html5新特性)

>在node环境下，process.nextTick的优先级高于Promise，也就是说：在宏任务结束后会先执行微任务队列中的nextTickQueue，然后才会执行微任务中的Promise。
### 执行上下文
浏览器执行JS函数其实是分两个过程的。一个是创建阶段Creation Phase,一个是执行阶段Execution Phase。
### setInterval(http://caibaojian.com/setinterval.html),requestAnimationFrame代替绘制动画

### Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__(https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create)
```javascript
// 创建一个原型为null的空对象
const pureObj  = Object.create(null)
```

### [设计模式](https://juejin.im/post/6846687601785585677)

### [前端模块化](https://juejin.im/post/6844903744518389768)
